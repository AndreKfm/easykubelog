@*@page "/searchfield"*@

<style>
    .search-margin { margin-right: 1.5rem; }
    .button-background { background: rgba(200, 200, 200, 0.9); border: 0; align-self: center}
</style>

@* ReSharper disable UnknownCssClass *@

<div class="input-group defpadding" style="align-self: center">
    <div class="input-group-prepend search-margin">
        @*<span class="input-group-text">Search</span>*@
        <button class="button-background" @onclick="ButtonSearch" style="height: 50%; align-self: center">Search</button>
        <div class="d-flex justify-content-center align-items-center m-2" style="@(Style)">
            <div class="spinner-grow spinner-grow-sm" role="status">
                <span class="sr-only">Loading...</span>
            </div>
        </div>
        <input class="form-control button-background" type="text" aria-label="Search text" @bind-value="_text"  @onkeyup="KeyPressed"  />
    </div>

    <div class="input-group-prepend search-margin" style="align-self: center">
        <span class="input-group-text button-background mr-1">Max</span>
        <input class="form-control button-background" type="number" aria-label="Search text" @bind-value="MaxElements"  @onkeyup="KeyPressed" style="max-width:7rem" />
    </div>

    <SearchFieldDateTime  @ref="FromDateTime" Name="From" />
    <SearchFieldDateTime  @ref="ToDateTime" Name="To" />

    @*<div class="input-group-prepend search-margin" style="align-items:center;">
            <input type="checkbox" aria-label="Enable date from" @bind-value="_enabledDateFrom" class="form-check" style="transform: scale(2.9);" />
            <span class="input-group-text" style="padding-left: 1.0rem;">From</span>
            <input type="datetime-local" aria-label="Search date from" style="@(_style)" @bind-value="DateFrom" disabled="@(!EnabledDateFrom)" @bind-value:event="oninput" @onkeyup="NewInput" class="form-control" />
        </div>*@
</div>

@using Microsoft.Extensions.Configuration;
@using System.Threading

@inject IConfiguration  _configuration;

@code {

    const int MaxElementsHighest = 2000;

    private SearchFieldDateTime _fromDateTime;
    private SearchFieldDateTime _toDateTime;
    // ReSharper disable once UnusedMember.Local
    private SearchFieldDateTime FromDateTime { get => _fromDateTime;
        set { _fromDateTime = value; _fromDateTime.NewInput = NewInput; } }
    // ReSharper disable once UnusedMember.Local
    private SearchFieldDateTime ToDateTime { get => _toDateTime;
        set { _toDateTime = value; _toDateTime.NewInput = NewInput; } }

    // ReSharper disable once FieldCanBeMadeReadOnly.Local
    private string _text = String.Empty;
    private int _maxElements = 100;

    public bool Searching { get; set; }

    static string GetSearchingStyle(bool state)
    {
        return state ? "color: green" : "visibility: hidden";
    }

    public string Style { get; set; } = GetSearchingStyle(false);

    const int DefaultDelay = 1000;
    Task _delayTask = Task.CompletedTask;
    System.Threading.CancellationTokenSource _tokenSource;

    public int MaxElements
    {
        get => _maxElements;
        set => _maxElements = value < MaxElementsHighest ? value : MaxElementsHighest;
    }

    public void DisplaySpinningSearch(bool state)
    {
        Searching = state;
        Style = GetSearchingStyle(state);
        InvokeAsync(StateHasChanged);
    }

    protected override void OnInitialized()
    {
        _maxElements = _configuration.GetValue<int>("MaxLogQueryResultLines");
    }

    string _lastQuery = String.Empty;

    private void ButtonSearch()
    {

        Console.WriteLine("Button Pressed");
        try
        {
            AbortInCaseOfRunning();
        }
        catch (Exception )
        {
        }
        _lastQuery = String.Empty;

        Interlocked.Exchange(ref _buttonPressed, 1);
        try
        {
            Console.WriteLine("Button Search");
            InternalNewInputDelayedAndThrottled(0);
        }
        catch (Exception )
        {
        }
        Interlocked.Exchange(ref _buttonPressed, 0);



    }

    private void NewInput()
    {
        lock (_lastQuery)
        {
            string currentQuery = _text + _maxElements.ToString() + _fromDateTime.Date.ToString() + _toDateTime.Date.ToString();
            if (currentQuery == _lastQuery)
                return;
            _lastQuery = currentQuery;
        }
        OnSearchQueryChange(_text, _maxElements, _fromDateTime.Date, _toDateTime.Date);
        StateHasChanged();
    }

    void AbortInCaseOfRunning()
    {
        _tokenSource?.Cancel();
        _delayTask?.Wait();
        _tokenSource?.Dispose();
        _tokenSource = null;
        _delayTask = null;
    }

    int _buttonPressed = 0;

    private void KeyPressed()
    {
        if (_buttonPressed == 0)
        {
            InternalNewInputDelayedAndThrottled(DefaultDelay);
        }
    }

    // Method will be called on each keystroke but it won't call immediately
    // NewInput but wait for additional keystrokes to come in
    private void NewInputDelayedAndThrottled()
    {
        InternalNewInputDelayedAndThrottled(DefaultDelay);
    }

    private void InternalNewInputDelayedAndThrottled(int delay)
    {
        AbortInCaseOfRunning();
        _tokenSource = new System.Threading.CancellationTokenSource();
        var localToken = _tokenSource.Token;
        Console.WriteLine("XXX CreateTask");

        _delayTask = Task.Run(async () =>
        {
            try
            {
                var token = localToken;
                await Task.Delay(delay, token);
                Console.WriteLine("XXX Search");
                await InvokeAsync(() =>
                {
                    DisplaySpinningSearch(true);
                    NewInput();
                });
            }
            catch (Exception)
            {
                Console.WriteLine("XXX Abort");
                // ignored
            }
        }, _tokenSource.Token);

    }

    public Action<string, int, DateTimeOffset, DateTimeOffset> OnSearchQueryChange;
}