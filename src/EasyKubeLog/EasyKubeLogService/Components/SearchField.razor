@*@page "/searchfield"*@


@* ReSharper disable UnknownCssClass *@

<div class="input-group defpadding" style="align-self: center">
    <div class="input-group-prepend search-margin">
        <MatButton style="@DynamicButtonBackground" Raised="true" @onclick="ButtonSearchOrAbort">@ButtonContent</MatButton>
        <MatProgressBar Indeterminate="true" Closed="@NotSearching" style="@_defaultStyles.DefaultControlsLayoutRemWidthPx(1.5, 30)"></MatProgressBar>
        <MatTextField style="@_defaultStyles.DefaultControlStyleTopScaled()" TValue="string" Label="Search For" @bind-Value="@Text"></MatTextField>
    </div>

    <div class="input-group-prepend" style="align-self: center">
        <MatNumericUpDownField style="@_defaultStyles.DefaultControlStyleTopScaled()" Minimum="0"
                               Label="Max Number of Search Items"
                               @bind-Value="@MaxElements"
                               @onkeyup="CountItemsChanged">
        </MatNumericUpDownField>
    </div>

    <SearchFieldDateTime @ref="FromDateTime" Name="From" />
    <SearchFieldDateTime @ref="ToDateTime" Name="To" />
</div>

@using Microsoft.Extensions.Configuration;
@using System.Threading
@using System.Runtime.InteropServices.WindowsRuntime
@using System.Globalization
@using EasyKubeLogService.Styles

@inject IConfiguration  _configuration;
@inject IButtonStyles  _buttonStyles;
@inject IDefaultStyles  _defaultStyles;

@code {

    //
    // Properties and member variables


    private SearchFieldDateTime _fromDateTime;
    private SearchFieldDateTime _toDateTime;

    // ReSharper disable once UnusedMember.Local
    private SearchFieldDateTime FromDateTime
    {
        get => _fromDateTime;
        set
        {
            _fromDateTime = value;
            TextChanged();
        }
    }

    // ReSharper disable once UnusedMember.Local
    private SearchFieldDateTime ToDateTime
    {
        get => _toDateTime;
        set
        {
            _toDateTime = value;
            TextChanged();
        }
    }

    // ReSharper disable once FieldCanBeMadeReadOnly.Local
    private string _text = String.Empty;

    public string Text
    {
        get => _text;
        set
        {
            _text = value;
            TextChanged();
        }
    }

    const int MaxElementsDefault = 100;


    private Task _delayTask = Task.CompletedTask;
    private System.Threading.CancellationTokenSource _tokenSource;

    private const int DefaultDelay = 100;
    private const int MaxElementsHighest = 2000;
    private int _maxElements = MaxElementsDefault;
    private int _maxElementsSearched = MaxElementsDefault;

    private bool _initialCall = false;
    private bool Searching { get; set; }
    private bool NotSearching => !Searching;
    private bool _buttonStateCurrentlyExecutingSearch = false;
    private string _lastQuery = String.Empty;
    private string _currentQuery = String.Empty;
    private string ButtonContent => (_buttonStateCurrentlyExecutingSearch == false) ? "Search" : "Abort";

    private string DynamicButtonBackground => (_buttonStateCurrentlyExecutingSearch == true) ?
             _buttonStyles.ButtonRedDefaultLayout() : _buttonStyles.ButtonGreenDefaultLayout();

    public string Style { get; set; } = GetSearchingStyle(false);


    private static string GetSearchingStyle(bool state)
    {
        return state ? "color: green" : "visibility: hidden";
    }



    private void SetDefaultState()
    {
        _buttonStateCurrentlyExecutingSearch = false;
        InvokeAsync(StateHasChanged);
    }

    private void SetSearchIsExecutingNowState()
    {
        _buttonStateCurrentlyExecutingSearch = true;
        InvokeAsync(StateHasChanged);
    }

    private void ButtonSearchOrAbort()
    {

        if (_buttonStateCurrentlyExecutingSearch)
            AbortCurrentSearch();

        SetLastQuery(_lastQuery + "#"); // Ensure that a search is executed

        InternalCheckCurrentSearchTextAndExecuteIfDifferentToLastDelayedAndThrottled(DefaultDelay);

    }

    private void AbortCurrentSearch()
    {
        AbortInCaseOfRunning();
        SetDefaultState();
    }

    private void ExecuteCurrentSearch()
    {
        InternalCheckCurrentSearchTextAndExecuteIfDifferentToLastDelayedAndThrottled(DefaultDelay);
    }

    private void TextChanged() { ExecuteCurrentSearch(); }

    private void CountItemsChanged() { ExecuteCurrentSearch();}

    private bool CheckCurrentSearchTextAndExecuteIfDifferentToLast()
    {
        lock (_lastQuery)
        {
            string currentQuery = _text + _maxElements.ToString() + _fromDateTime.Date.ToString() + _toDateTime.Date.ToString();
            if ((currentQuery == _lastQuery) && (_maxElementsSearched == _maxElements))
                return false;
            _currentQuery = currentQuery;
            _maxElementsSearched = _maxElements;

        }
        InvokeAsync(() =>
            OnSearchQueryChange(_text, _maxElements, _fromDateTime.Date, _toDateTime.Date));
        StateHasChanged();
        return true;
    }

    private void AbortInCaseOfRunning()
    {
        _tokenSource?.Cancel();
        _delayTask?.Wait();
        _tokenSource?.Dispose();
        _tokenSource = null;
        _delayTask = null;
    }



    private void InternalCheckCurrentSearchTextAndExecuteIfDifferentToLastDelayedAndThrottled(int delay)
    {
        if (_initialCall == false)
        {
            _initialCall = true;
            Task.Delay(DefaultDelay * 3).Wait(); // If we don't do that on startup an cancelled exception will be thrown
                                                 // because not everything has been initialized yet - the reason is not quite clear
                                                 // and in worst case on slower system the initial search might not be executed
                                                 // TODO: check if there is a RenderFinished call
        }
        else AbortInCaseOfRunning();
        _tokenSource = new System.Threading.CancellationTokenSource();
        var localToken = _tokenSource.Token;
        InvokeAsync(SetDefaultState);

        InternalExecuteSearchAsync(delay, localToken);

    }

    private void InternalExecuteSearchAsync(int delay, CancellationToken localToken)
    {
        _delayTask = Task.Run(async () =>
        {
            try
            {
                var token = localToken;
                await Task.Delay(delay, token);
                _ = InvokeAsync(() =>
                {
                    DisplaySpinningSearch(true);
                    InvokeAsync(SetSearchIsExecutingNowState);
                    if (!CheckCurrentSearchTextAndExecuteIfDifferentToLast())
                    {
                        DisplaySpinningSearch(false);
                        SetDefaultState();
                    }
                });
            }
            catch (Exception)
            {
                // ignored
            }

            SetLastQuery(_currentQuery);

            _ = InvokeAsync(SetDefaultState); // Ignore task here - otherwise UI is blocked
        }, _tokenSource.Token);
    }

    private void SetLastQuery(string query)
    {
        lock (_lastQuery)
        {
            _lastQuery = query;
        }
    }

    protected override void OnInitialized()
    {
        _maxElements = _configuration.GetValue<int>("MaxLogQueryResultLines");
    }

    public Action<string, int, DateTimeOffset, DateTimeOffset> OnSearchQueryChange;
    public int MaxElements
    {
        get => _maxElements;
        set
        {
            _maxElements = value < MaxElementsHighest ? value : MaxElementsHighest;
            ExecuteCurrentSearch();
        }
    }

    public void DisplaySpinningSearch(bool state)
    {
        Searching = state;
        Style = GetSearchingStyle(state);
        InvokeAsync(StateHasChanged);
    }

}